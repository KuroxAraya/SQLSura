# SQLSura
Durante el periodo en que finalizaba la actualización de las tablas se me requirió cambiar la herramienta de trabajo pues el uso y dependencia de archivos planos (Excel) de información no eran efectivos ni factibles para el objetivo principal de la automatización de las tareas. Determinando, esa misma semana, el uso de SQL para el manejo de estos datos. La propuesta era exactamente la misma, pero que a través del uso de las Bases de Datos se mantiene un control más globalizado y confiable de los registros.
•	FASE PRELIMINAR. Con los bases de información existentes debí determinar identificadores únicos para cada registro, para lo cual añadí una columna IDHIST auto incrementable (cada registro tiene un número n+1) que permitiera al analista determinar y trabajar con datos escalables e identificables en el entorno de la BD TH_AD. En el caso de la vacaciones al no existir otros datos tan completos como en Licencias añadí una columna ULT_ACT que toma la fecha del sistema con GETDATE() automáticamente para mantener en “inventario” de estos registros.

•	AMPLIACIÓN DE PERIODOS EN SQL. En este caso, y dado el cambio de tecnologías, para la automatización se reemplaza el uso de botones por procedimientos almacenados, que funcionan como los módulos de Excel y se ejecutan haciendo uso del comando EXEC [NOMBRE DEL PROCEDIMIENTO], para la ampliación se crea una CTE (Tabla de Expresión Común) que crea tablas temporales y dinámicas, además se realizó un procedimiento similar al de Excel, pero inicialmente se hace una selección de tablas del sistema (del SQL propio) y de la tabla conteniendo los registros para realizar la separación y cálculo de estos. Para cada registro se calcula la diferencia en meses con DATEDIFF() y se añade DATEADD() para el periodo en la ampliación y cálculo ampliado y corte (si es necesario), el procedimiento además se hizo a prueba de años bisiestos. El requerimiento pide también mantener las fechas iniciales, finales y cálculos originales con formato DD/MM/YYYY y DD respectivamente para lo cual se anidó otra CTE que utilice (seleccione) las columnas de la tabla generada previamente y la que tiene los datos históricos, y en el formato di uso de CONVERT() para mostrar las fechas como correspondían. Finalmente en una tercera CTE hago el nuevo cálculo de días entre periodos con DATEDIFF() y genero la columna con la ID de PERPRO que se insertan con la expresión INSERT INTO en la tabla que almacena los datos procesados históricamente.
Repositorio Git: https://github.com/KuroxAraya/SQLSura/blob/master/ampLic.sql

•	CÁLCULO DE DÍAS LABORALES. Para el cálculo de días laborales en el caso de las Vacaciones y Permisos fue necesario generar una tabla calendario que almacenara todos los días desde determinadas fechas incluyendo todos los feriados bancarios y fines de semana que podrían existir localmente. Por lo tanto, con una transacción de SQL se llenó inicialmente todos los días existentes desde las fechas predeterminadas desde X a Y (2010-2030 en este caso) con los valores por cada registro la fecha sin formato (IDCal = YYYYMMDD) la fecha larga (fechaValor = YYYY-MM-DD HH:MN:MS), el día de la semana (numDiaSemana = DW, e. g. Lunes = 1 / Viernes = 5) el nombre del día, el mes, la semana del año, día juliano, y si es feriado o no (feriadoBancario = True/False, e. g. Año nuevo = 1) y su nombre en el caso de existir. Para los fines de semana se llenó automáticamente donde los días de la semana tuviesen valor 6 o 7 (Sábado o Domingo). Los feriados, debido a la naturaleza de la determinación de estos (si se otorga sándwich o si x feriado se corre para x día), debieron ser ingresados manualmente, encontrando principalmente problemas en Semana Santa, San Pedro y San Pablo, el Día de la Raza y el sándwich de Fiestas Patrias. Para el cálculo de días laborales en el tercer CTE de la ampliación de registros en vez de utilizar DATEDIFF() (que no permite cálculos complejos como por ejemplo los días laborales) usé una selección anidada que tomara la fecha inicial y final del registro y que contara los días no laborales entre estas fechas y restarlos a la cantidad de días totales, matemáticamente expresado como: ((FECHA INICIAL – FECHA FINAL) – NO LABORALES DURANTE PERIODO) = DIAS LABORALES.
Repositorio Git: https://github.com/KuroxAraya/calendiarioSQL_CL
		https://github.com/KuroxAraya/SQLSura/blob/master/ampVac.sql

•	VALIDACIÓN DE SOLAPADOS. En el sistema pueden existir distintos casos en que registros pertenecientes al mismo usuario pero que poseen fechas solapadas por distintos motivos (actualización, doble ingreso, etc.). Para este caso se me hizo sugerencia de utilizar cursores, que, siendo efectivos en el proceso, no eran factibles para el tiempo en que terminaba de procesar los datos (30 minutos para 30k registros) por lo que con un procedimiento almacenado y una CTE agrupé los registros en base a la ID histórica creada anteriormente (y que se duplica junto con la ampliación) y con ROW_NUMBER() son ordenarlos en base al valor ULT_ACT (fecha en que el usuario subió el registro) y que con una auto referencia busque donde exista el mismo registro pero con fechas solapadas.
Repositorio Git: https://github.com/KuroxAraya/SQLSura/blob/master/validaSolapamiento.sql

•	VISTAS Y UNIÓN DE DOTACIÓN. Finalmente, el último proceso para tener el reporte completo es la unión de la tabla procesada y una tabla de dotación. Para la unión generé una vista que permite la unión dinámica de tablas y almacenar independientemente la estructura deseada de la tabla (cualquier cambio en las tablas será representado automáticamente en la vista asociada). En la unión se utilizó un LEFT OUTER JOIN, que mantiene los datos de la tabla izquierda y une donde existan los datos de la tabla derecha. En este caso, si en la dotación faltan datos, en la vista esos datos inexistentes se van a mostrar como NULL.
